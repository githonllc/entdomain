{{/* gotype: entgo.io/ent/entc/gen.Type */}}

// Code generated by entdomain extension. DO NOT EDIT.

package {{ base $.Config.Package }}

import (
	"fmt"
	"time"
	"{{ entdomainPkg }}"
{{- if domainFields $ }}
	"{{ $.Config.Package }}/{{ $.Package }}"
{{- end }}
)

// ============================================================================================
// Layered Architecture Overview:
//
// 1. DomainModel - The complete domain model containing all fields, not restricted by HTTP scope.
//    - Operated on by the Service and Repository layers.
//    - Contains the full entity state and business logic.
//    - All fields are accessible and modifiable by the Service/Repository layers.
//
// 2. CreateRequest/UpdateRequest - HTTP-layer request models, restricted by scope.
//    - Only includes fields for the corresponding scope (ScopeCreate/ScopeUpdate).
//    - Used by the Handler layer to receive HTTP requests.
//    - Certain fields (e.g., ID, audit fields) cannot be set via the HTTP API.
//
// 3. Response - HTTP-layer response model, restricted by scope.
//    - Only includes fields in ScopeResponse.
//    - Used by the Handler layer to return HTTP responses.
//    - Sensitive fields (e.g., password) are excluded from responses.
//
// 4. QueryParams - HTTP-layer query parameter model, restricted by scope.
//    - Only includes fields in ScopeQuery.
//    - Used by the Handler layer to receive query parameters.
//    - Supports searchable, filterable, and sortable fields.
//
// Key Design Principles:
// - HTTP scope only affects struct generation for the Handler layer.
// - The Service layer handles full business logic with the complete domain model.
// - The Repository layer has full access to all entity fields.
// ============================================================================================

{{- $domainFields := domainFields $ }}
{{- if $domainFields }}

// {{ $.Name }}DomainModel represents the complete domain model for {{ $.Name }}.
// It contains all fields and is used by the Service and Repository layers
// for business logic processing.
type {{ $.Name }}DomainModel struct {
	// ID field is always included
	{{ $.ID.StructField }} {{ $.ID.Type }} `json:"{{ $.ID.StorageKey }}"`
{{- range $f := $domainFields }}
	{{- if ne $f.Name "id" }}
	{{ $f.StructField }} {{ $f.Type }} `json:"{{ $f.StorageKey }}"`
	{{- end }}
{{- end }}
}

// GetID returns the entity ID
func (m *{{ $.Name }}DomainModel) GetID() entdomain.ID {
	{{- if eq $.ID.Type.String "string" }}
	return entdomain.NewIDFromString(m.{{ $.ID.StructField }})
	{{- else if eq $.ID.Type.String "int64" }}
	return entdomain.NewIDFromInt64(m.{{ $.ID.StructField }})
	{{- else }}
	return entdomain.NewIDFromString(fmt.Sprintf("%v", m.{{ $.ID.StructField }}))
	{{- end }}
}

// SetID sets the entity ID
func (m *{{ $.Name }}DomainModel) SetID(id entdomain.ID) {
	{{- if eq $.ID.Type.String "string" }}
	m.{{ $.ID.StructField }} = id.String()
	{{- else if eq $.ID.Type.String "int64" }}
	if i, err := id.Int64(); err == nil {
		m.{{ $.ID.StructField }} = i
	}
	{{- else }}
	m.{{ $.ID.StructField }} = id.String()
	{{- end }}
}

// Clone creates a deep copy of the domain model
func (m *{{ $.Name }}DomainModel) Clone() entdomain.DomainModel {
	if m == nil {
		return nil
	}
	clone := *m
{{- range $f := $domainFields }}
{{- if ne $f.Name "id" }}
{{- if hasPrefix $f.Type.String "[]" }}
	if m.{{ $f.StructField }} != nil {
		clone.{{ $f.StructField }} = make({{ $f.Type }}, len(m.{{ $f.StructField }}))
		copy(clone.{{ $f.StructField }}, m.{{ $f.StructField }})
	}
{{- else if hasPrefix $f.Type.String "map[" }}
	if m.{{ $f.StructField }} != nil {
		clone.{{ $f.StructField }} = make({{ $f.Type }}, len(m.{{ $f.StructField }}))
		for k, v := range m.{{ $f.StructField }} {
			clone.{{ $f.StructField }}[k] = v
		}
	}
{{- end }}
{{- end }}
{{- end }}
	return &clone
}

// ToResponse converts domain model to response
func (m *{{ $.Name }}DomainModel) ToResponse() *{{ $.Name }}Response {
	if m == nil {
		return nil
	}
	return &{{ $.Name }}Response{
{{- range $f := responseFields $ }}
	{{- if $f.Optional }}
		{{- if eq $f.Type.String "string" }}
		{{ $f.StructField }}: entdomain.PtrOrNil(m.{{ $f.StructField }}),
		{{- else if eq $f.Type.String "time.Time" }}
		{{ $f.StructField }}: entdomain.PtrTimeOrNil(m.{{ $f.StructField }}),
		{{- else }}
		{{ $f.StructField }}: entdomain.Ptr(m.{{ $f.StructField }}),
		{{- end }}
	{{- else }}
		{{ $f.StructField }}: m.{{ $f.StructField }},
	{{- end }}
{{- end }}
	}
}

// ToListResponse converts a slice of domain models to list response
func ({{ $.Name }}DomainModel) ToListResponse(models []*{{ $.Name }}DomainModel, total, page, size int) *{{ $.Name }}ListResponse {
	if models == nil {
		return &{{ $.Name }}ListResponse{
			Data:  []*{{ $.Name }}Response{},
			Total: 0,
			Page:  page,
			Size:  size,
		}
	}

	data := make([]*{{ $.Name }}Response, 0, len(models))
	for _, model := range models {
		if response := model.ToResponse(); response != nil {
			data = append(data, response)
		}
	}

	return &{{ $.Name }}ListResponse{
		Data:  data,
		Total: total,
		Page:  page,
		Size:  size,
	}
}

{{- $createFields := createFields $ }}
{{- if $createFields }}

// {{ $.Name }}CreateRequest represents the create request for {{ $.Name }}
type {{ $.Name }}CreateRequest struct {
{{- range $f := $createFields }}
	{{- if isDomainRequired $f "create" }}
	{{ $f.StructField }} {{ $f.Type }} `json:"{{ $f.StorageKey }}" validate:"required"`
	{{- else }}
	{{ $f.StructField }} {{ if $f.Optional }}*{{ end }}{{ $f.Type }} `json:"{{ $f.StorageKey }},omitempty"`
	{{- end }}
{{- end }}
}

// Validate validates the create request
func (r *{{ $.Name }}CreateRequest) Validate() error {
	if r == nil {
		return fmt.Errorf("create request cannot be nil")
	}
{{- range $f := $createFields }}
{{- if isDomainRequired $f "create" }}
{{- if eq $f.Type.String "string" }}
	if r.{{ $f.StructField }} == "" {
		return fmt.Errorf("{{ $f.StorageKey }} is required")
	}
{{- end }}
{{- end }}
{{- end }}
	return nil
}

// ToDomainModel converts create request to domain model
func (r *{{ $.Name }}CreateRequest) ToDomainModel() entdomain.DomainModel {
	if r == nil {
		return nil
	}
	return &{{ $.Name }}DomainModel{
{{- range $f := $createFields }}
	{{- if isDomainRequired $f "create" }}
		{{ $f.StructField }}: r.{{ $f.StructField }},
	{{- else if $f.Optional }}
		{{ $f.StructField }}: func() {{ $f.Type }} {
			if r.{{ $f.StructField }} != nil {
				return *r.{{ $f.StructField }}
			}
			{{- if eq $f.Type.String "string" }}
			return ""
			{{- else if eq $f.Type.String "time.Time" }}
			return time.Time{}
			{{- else }}
			var zero {{ $f.Type }}
			return zero
			{{- end }}
		}(),
	{{- else }}
		{{ $f.StructField }}: r.{{ $f.StructField }},
	{{- end }}
{{- end }}
	}
}

{{- end }}

{{- $updateFields := updateFields $ }}
{{- if $updateFields }}

// {{ $.Name }}UpdateRequest represents the update request for {{ $.Name }}
type {{ $.Name }}UpdateRequest struct {
{{- range $f := $updateFields }}
	{{ $f.StructField }} *{{ $f.Type }} `json:"{{ $f.StorageKey }},omitempty"`
{{- end }}
}

// Validate validates the update request
func (r *{{ $.Name }}UpdateRequest) Validate() error {
	if r == nil {
		return fmt.Errorf("update request cannot be nil")
	}
{{- range $f := $updateFields }}
{{- if isDomainRequired $f "update" }}
	if r.{{ $f.StructField }} == nil {
		return fmt.Errorf("{{ $f.StorageKey }} is required")
	}
{{- if eq $f.Type.String "string" }}
	if *r.{{ $f.StructField }} == "" {
		return fmt.Errorf("{{ $f.StorageKey }} cannot be empty")
	}
{{- end }}
{{- end }}
{{- end }}
	return nil
}

// ToDomainModel converts update request to domain model
func (r *{{ $.Name }}UpdateRequest) ToDomainModel() entdomain.DomainModel {
	if r == nil {
		return nil
	}
	model := &{{ $.Name }}DomainModel{}
{{- range $f := $updateFields }}
	if r.{{ $f.StructField }} != nil {
		model.{{ $f.StructField }} = *r.{{ $f.StructField }}
	}
{{- end }}
	return model
}

// ApplyToDomainModel applies update request to existing domain model
func (r *{{ $.Name }}UpdateRequest) ApplyToDomainModel(m entdomain.DomainModel) entdomain.DomainModel {
	if r == nil || m == nil {
		return m
	}
	model, ok := m.(*{{ $.Name }}DomainModel)
	if !ok {
		return m
	}
{{- range $f := $updateFields }}
	if r.{{ $f.StructField }} != nil {
		model.{{ $f.StructField }} = *r.{{ $f.StructField }}
	}
{{- end }}
	return model
}

{{- end }}

{{- $responseFields := responseFields $ }}
{{- if $responseFields }}

// {{ $.Name }}Response represents the response for {{ $.Name }}
type {{ $.Name }}Response struct {
{{- range $f := $responseFields }}
	{{- if $f.Optional }}
	{{ $f.StructField }} *{{ $f.Type }} `json:"{{ $f.StorageKey }},omitempty"`
	{{- else }}
	{{ $f.StructField }} {{ $f.Type }} `json:"{{ $f.StorageKey }}"`
	{{- end }}
{{- end }}
}

{{- end }}

{{- $queryFields := queryFields $ }}
{{- if $queryFields }}

// {{ $.Name }}QueryParams represents query parameters for {{ $.Name }}
type {{ $.Name }}QueryParams struct {
	Query string `json:"query,omitempty" form:"query"`
	Page  int    `json:"page,omitempty" form:"page"`
	Size  int    `json:"size,omitempty" form:"size"`
{{- range $f := $queryFields }}
	{{ $f.StructField }} {{ if $f.Optional }}*{{ end }}{{ $f.Type }} `json:"{{ $f.StorageKey }},omitempty" form:"{{ $f.StorageKey }}"`
{{- end }}
}

// Validate validates the query parameters
func (q *{{ $.Name }}QueryParams) Validate() error {
	if q == nil {
		return fmt.Errorf("query parameters cannot be nil")
	}
	return nil
}

// ToSearchRequest converts the typed query parameters to a generic SearchRequest
// used by the repository layer.
func (q *{{ $.Name }}QueryParams) ToSearchRequest() *entdomain.SearchRequest {
	if q == nil {
		return &entdomain.SearchRequest{
			Size:    entdomain.DefaultPageSize,
			Filters: make(map[string]any),
		}
	}

	size := q.Size
	if size <= 0 {
		size = entdomain.DefaultPageSize
	}

	filters := make(map[string]any)
{{- range $f := $queryFields }}
	{{- if $f.Optional }}
	if q.{{ $f.StructField }} != nil {
		filters["{{ lower $f.Name }}"] = *q.{{ $f.StructField }}
	}
	{{- else }}
	{{- if eq $f.Type.String "string" }}
	if q.{{ $f.StructField }} != "" {
		filters["{{ lower $f.Name }}"] = q.{{ $f.StructField }}
	}
	{{- else if eq $f.Type.String "bool" }}
	if q.{{ $f.StructField }} {
		filters["{{ lower $f.Name }}"] = q.{{ $f.StructField }}
	}
	{{- else if eq $f.Type.String "int" }}
	if q.{{ $f.StructField }} != 0 {
		filters["{{ lower $f.Name }}"] = q.{{ $f.StructField }}
	}
	{{- else if eq $f.Type.String "int64" }}
	if q.{{ $f.StructField }} != 0 {
		filters["{{ lower $f.Name }}"] = q.{{ $f.StructField }}
	}
	{{- else }}
	filters["{{ lower $f.Name }}"] = q.{{ $f.StructField }}
	{{- end }}
	{{- end }}
{{- end }}

	return &entdomain.SearchRequest{
		Query:   q.Query,
		Filters: filters,
		Size:    size,
		Page:    q.Page,
	}
}

{{- end }}

// {{ $.Name }}ListResponse represents the list response for {{ $.Name }}
type {{ $.Name }}ListResponse struct {
	Data     []*{{ $.Name }}Response  `json:"data"`
	Total    int                      `json:"total"`
	Page     int                      `json:"page"`
	Size     int                      `json:"size"`
	PageInfo *entdomain.PageInfo      `json:"pageInfo,omitempty"`
}

{{- end }}