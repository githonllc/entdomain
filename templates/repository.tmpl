{{/* gotype: entgo.io/ent/entc/gen.Type */}}

// Code generated by entdomain extension. DO NOT EDIT.

package {{ base $.Config.Package }}

import (
	"context"
	"fmt"
{{- if hasTimeFields $ }}
	"time"
{{- end }}

	"{{ $.Config.Package }}/{{ $.Package }}"
	"{{ $.Config.Package }}/predicate"
	"{{ entdomainPkg }}"
	"entgo.io/ent/dialect/sql"
)

{{- $domainFields := domainFields $ }}
{{- if $domainFields }}

// {{ $.Name }}Repository defines the repository interface for {{ $.Name }}.
// The Repository layer is responsible for concrete data storage and retrieval logic.
// Responsibilities:
// 1. Provide basic CRUD operations.
// 2. Implement data storage abstraction.
// 3. Handle data-level constraint validation.
// 4. Provide field-based query methods.
type {{ $.Name }}Repository interface {
	// Standard CRUD operations
	Create(ctx context.Context, model *{{ $.Name }}DomainModel) (*{{ $.Name }}DomainModel, error)
	GetByID(ctx context.Context, id entdomain.ID) (*{{ $.Name }}DomainModel, error)
	Update(ctx context.Context, model *{{ $.Name }}DomainModel) (*{{ $.Name }}DomainModel, error)
	Delete(ctx context.Context, id entdomain.ID) error
	CreateBatch(ctx context.Context, models []*{{ $.Name }}DomainModel) ([]*{{ $.Name }}DomainModel, error)
	UpdateBatch(ctx context.Context, models []*{{ $.Name }}DomainModel) ([]*{{ $.Name }}DomainModel, error)
	DeleteBatch(ctx context.Context, ids []entdomain.ID) error
	List(ctx context.Context, req *entdomain.ListRequest) ([]*{{ $.Name }}DomainModel, int, error)
	ListByCursor(ctx context.Context, req *entdomain.ListRequest) ([]*{{ $.Name }}DomainModel, *entdomain.PageInfo, error)
	Search(ctx context.Context, req *entdomain.SearchRequest) ([]*{{ $.Name }}DomainModel, int, error)
	Count(ctx context.Context, req *entdomain.SearchRequest) (int, error)
	Exists(ctx context.Context, id entdomain.ID) (bool, error)
	FindBy(ctx context.Context, field string, value any) ([]*{{ $.Name }}DomainModel, error)
	FindOneBy(ctx context.Context, field string, value any) (*{{ $.Name }}DomainModel, error)
	WithTx(ctx context.Context, fn func(repo {{ $.Name }}Repository) error) error
{{- range $field := uniqueLookupFields $ }}
	FindBy{{ $field.StructField }}(ctx context.Context, {{ lower $field.Name }} {{ $field.Type }}) (*{{ $.Name }}DomainModel, error)
{{- end }}
{{- range $field := rangeLookupFields $ }}
	FindBy{{ $field.StructField }}Range(ctx context.Context, start, end time.Time) ([]*{{ $.Name }}DomainModel, error)
{{- end }}
}

// {{ $.Name }}RepositoryImpl implements {{ $.Name }}Repository using Ent
type {{ $.Name }}RepositoryImpl struct {
	client *Client
}

// New{{ $.Name }}Repository creates a new {{ $.Name }} repository
func New{{ $.Name }}Repository(client *Client) {{ $.Name }}Repository {
	return &{{ $.Name }}RepositoryImpl{
		client: client,
	}
}

// Create creates a new {{ $.Name }}
func (r *{{ $.Name }}RepositoryImpl) Create(ctx context.Context, model *{{ $.Name }}DomainModel) (*{{ $.Name }}DomainModel, error) {
	entity, err := r.client.{{ $.Name }}.
		Create().
{{- range $field := $domainFields }}
{{- if not $field.Default }}
		{{ setFieldCall $field $ }}.
{{- end }}
{{- end }}
		Save(ctx)
	if err != nil {
		if IsConstraintError(err) {
			return nil, fmt.Errorf("%w: %v", entdomain.ErrAlreadyExists, err)
		}
		return nil, err
	}

	return r.entToDomain(entity), nil
}

// GetByID retrieves a {{ $.Name }} by ID
func (r *{{ $.Name }}RepositoryImpl) GetByID(ctx context.Context, id entdomain.ID) (*{{ $.Name }}DomainModel, error) {
	{{ generateIdOperation $ "get" "id" }}
	if err != nil {
		if IsNotFound(err) {
			return nil, fmt.Errorf("%w: {{ lower $.Name }} %s", entdomain.ErrNotFound, id)
		}
		return nil, err
	}

	return r.entToDomain(entity), nil
}

// Update updates a {{ $.Name }}
func (r *{{ $.Name }}RepositoryImpl) Update(ctx context.Context, model *{{ $.Name }}DomainModel) (*{{ $.Name }}DomainModel, error) {
	{{ generateIdOperation $ "updateOneID" "model" }}
{{- range $field := updateableFields $ }}
		{{ setFieldCall $field $ }}.
{{- end }}
		Save(ctx)
	if err != nil {
		if IsNotFound(err) {
			return nil, fmt.Errorf("%w: {{ lower $.Name }} %v", entdomain.ErrNotFound, model.{{ $.ID.StructField }})
		}
		if IsConstraintError(err) {
			return nil, fmt.Errorf("%w: %v", entdomain.ErrAlreadyExists, err)
		}
		return nil, err
	}

	return r.entToDomain(entity), nil
}

// Delete deletes a {{ $.Name }} by ID
func (r *{{ $.Name }}RepositoryImpl) Delete(ctx context.Context, id entdomain.ID) error {
	{{ generateIdOperation $ "delete" "id" }}
}

// CreateBatch creates multiple {{ $.Name }}s
func (r *{{ $.Name }}RepositoryImpl) CreateBatch(ctx context.Context, models []*{{ $.Name }}DomainModel) ([]*{{ $.Name }}DomainModel, error) {
	if len(models) == 0 {
		return []*{{ $.Name }}DomainModel{}, nil
	}

	builders := make([]*{{ $.Name }}Create, len(models))
{{- $createFields := nonDefaultDomainFields $ }}
	for i, model := range models {
		builders[i] = r.client.{{ $.Name }}.Create().
{{- range $field := $createFields }}
			{{ setFieldCall $field $ }}
{{- if ne $field (last $createFields) }}.{{- end }}
{{- end }}
	}

	entities, err := r.client.{{ $.Name }}.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	return result, nil
}

// UpdateBatch updates models sequentially. For large batches, consider
// using WithTx to wrap this in a single transaction.
func (r *{{ $.Name }}RepositoryImpl) UpdateBatch(ctx context.Context, models []*{{ $.Name }}DomainModel) ([]*{{ $.Name }}DomainModel, error) {
	if len(models) == 0 {
		return []*{{ $.Name }}DomainModel{}, nil
	}

	result := make([]*{{ $.Name }}DomainModel, len(models))
	for i, model := range models {
		updated, err := r.Update(ctx, model)
		if err != nil {
			return nil, err
		}
		result[i] = updated
	}

	return result, nil
}

// DeleteBatch deletes multiple {{ $.Name }}s by IDs
func (r *{{ $.Name }}RepositoryImpl) DeleteBatch(ctx context.Context, ids []entdomain.ID) error {
	if len(ids) == 0 {
		return nil
	}

	{{ generateIdOperation $ "batchDelete" "ids" }}
	return err
}

// List retrieves a list of {{ $.Name }}s with pagination and sorting
func (r *{{ $.Name }}RepositoryImpl) List(ctx context.Context, req *entdomain.ListRequest) ([]*{{ $.Name }}DomainModel, int, error) {
	query := r.client.{{ $.Name }}.Query()

	// Count total before sorting/pagination (avoid ORDER BY in count query)
	total, err := query.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	// Apply sorting
	if req.SortBy != "" {
		order := sql.OrderDesc()
		if req.Order == "asc" {
			order = sql.OrderAsc()
		}

		switch req.SortBy {
{{- range $field := sortableFields $ }}
		case "{{ lower $field.Name }}":
			query = query.Order({{ $.Package }}.By{{ $field.StructField }}(order))
{{- end }}
		default:
			query = query.Order({{ $.Package }}.ByID(order))
		}
	} else {
		query = query.Order({{ $.Package }}.ByID(sql.OrderDesc()))
	}

	// Apply pagination
	if req.Page > 0 {
		query = query.Offset((req.Page - 1) * req.Size)
	}
	if req.Size > 0 {
		query = query.Limit(req.Size)
	}

	entities, err := query.All(ctx)
	if err != nil {
		return nil, 0, err
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	return result, total, nil
}

// ListByCursor retrieves {{ $.Name }}s using cursor-based (keyset) pagination.
// This is more efficient than offset pagination for large datasets because it
// seeks directly to the cursor position via an index instead of scanning rows.
func (r *{{ $.Name }}RepositoryImpl) ListByCursor(ctx context.Context, req *entdomain.ListRequest) ([]*{{ $.Name }}DomainModel, *entdomain.PageInfo, error) {
	query := r.client.{{ $.Name }}.Query()

	// Determine sort column and direction
	sortColumn := {{ $.Package }}.FieldID
	isAsc := req.Order == "asc"

	switch req.SortBy {
{{- range $field := sortableFields $ }}
	case "{{ lower $field.Name }}":
		sortColumn = {{ $.Package }}.Field{{ $field.StructField }}
{{- end }}
	}

	// Apply cursor seek predicate
	if req.Cursor != "" {
		cursor, err := entdomain.DecodeCursor(req.Cursor)
		if err != nil {
			return nil, nil, fmt.Errorf("invalid cursor: %w", err)
		}
		query = query.Where(func(s *sql.Selector) {
			if sortColumn == {{ $.Package }}.FieldID {
				if isAsc {
					s.Where(sql.GT(s.C({{ $.Package }}.FieldID), cursor.ID))
				} else {
					s.Where(sql.LT(s.C({{ $.Package }}.FieldID), cursor.ID))
				}
			} else {
				cols := []string{s.C(sortColumn), s.C({{ $.Package }}.FieldID)}
				if isAsc {
					s.Where(sql.CompositeGT(cols, cursor.Value, cursor.ID))
				} else {
					s.Where(sql.CompositeLT(cols, cursor.Value, cursor.ID))
				}
			}
		})
	}

	// Apply sort order
	order := sql.OrderDesc()
	if isAsc {
		order = sql.OrderAsc()
	}
	switch req.SortBy {
{{- range $field := sortableFields $ }}
	case "{{ lower $field.Name }}":
		query = query.Order({{ $.Package }}.By{{ $field.StructField }}(order))
{{- end }}
	default:
		query = query.Order({{ $.Package }}.ByID(order))
	}

	// Fetch size+1 to detect hasNextPage without a count query
	limit := req.Size
	if limit <= 0 {
		limit = entdomain.DefaultPageSize
	}
	entities, err := query.Limit(limit + 1).All(ctx)
	if err != nil {
		return nil, nil, err
	}

	hasNext := len(entities) > limit
	if hasNext {
		entities = entities[:limit]
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	pageInfo := &entdomain.PageInfo{HasNextPage: hasNext}
	if len(entities) > 0 {
		last := entities[len(entities)-1]
		pageInfo.EndCursor = r.buildCursor(last, req.SortBy)
	}

	return result, pageInfo, nil
}

// buildCursor builds an opaque cursor string from the last entity in a page.
func (r *{{ $.Name }}RepositoryImpl) buildCursor(entity *{{ $.Name }}, sortBy string) string {
	cursor := &entdomain.Cursor{ID: entity.{{ $.ID.StructField }}}
	switch sortBy {
{{- range $field := sortableFields $ }}
	case "{{ lower $field.Name }}":
		cursor.Value = entity.{{ $field.StructField }}
{{- end }}
	}
	return entdomain.EncodeCursor(cursor)
}

// Search searches {{ $.Name }}s based on criteria
func (r *{{ $.Name }}RepositoryImpl) Search(ctx context.Context, req *entdomain.SearchRequest) ([]*{{ $.Name }}DomainModel, int, error) {
	query := r.client.{{ $.Name }}.Query()

	// Apply search predicates
	if req.Query != "" {
		predicates := []predicate.{{ $.Name }}{}
{{- range $field := searchableFields $ }}
		{{ generateSearchCondition $field $ }}
{{- end }}

		if len(predicates) > 0 {
			query = query.Where({{ $.Package }}.Or(predicates...))
		}
	}

	// Apply filters
	for field, value := range req.Filters {
		switch field {
{{- range $field := $domainFields }}
{{- if ne $field.Name "id" }}
		case "{{ lower $field.Name }}":
			{{ searchMethod $field $ }}
{{- end }}
{{- end }}
		}
	}

	// Count total before sorting/pagination
	total, err := query.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	// Apply sorting
	if req.SortBy != "" {
		order := sql.OrderDesc()
		if req.Order == "asc" {
			order = sql.OrderAsc()
		}

		switch req.SortBy {
{{- range $field := sortableFields $ }}
		case "{{ lower $field.Name }}":
			query = query.Order({{ $.Package }}.By{{ $field.StructField }}(order))
{{- end }}
		default:
			query = query.Order({{ $.Package }}.ByID(order))
		}
	}

	// Apply pagination
	if req.Page > 0 {
		query = query.Offset((req.Page - 1) * req.Size)
	}
	if req.Size > 0 {
		query = query.Limit(req.Size)
	}

	entities, err := query.All(ctx)
	if err != nil {
		return nil, 0, err
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	return result, total, nil
}

// Count counts {{ $.Name }}s based on criteria
func (r *{{ $.Name }}RepositoryImpl) Count(ctx context.Context, req *entdomain.SearchRequest) (int, error) {
	query := r.client.{{ $.Name }}.Query()

	// Apply search filters
	if req.Query != "" {
		// Create OR conditions for all searchable fields
		predicates := []predicate.{{ $.Name }}{}
{{- range $field := searchableFields $ }}
		{{ generateSearchCondition $field $ }}
{{- end }}

		if len(predicates) > 0 {
			query = query.Where({{ $.Package }}.Or(predicates...))
		}
	}

	// Apply additional filters from criteria
	for field, value := range req.Filters {
		switch field {
{{- range $field := $domainFields }}
{{- if ne $field.Name "id" }}
		case "{{ lower $field.Name }}":
			{{ searchMethod $field $ }}
{{- end }}
{{- end }}
		}
	}

	return query.Count(ctx)
}

// Exists checks if a {{ $.Name }} exists by ID
func (r *{{ $.Name }}RepositoryImpl) Exists(ctx context.Context, id entdomain.ID) (bool, error) {
	{{ generateIdOperation $ "exists" "id" }}
	return count > 0, err
}

// FindBy finds {{ $.Name }}s by field value
func (r *{{ $.Name }}RepositoryImpl) FindBy(ctx context.Context, field string, value any) ([]*{{ $.Name }}DomainModel, error) {
	query := r.client.{{ $.Name }}.Query()

	switch field {
{{- range $field := $domainFields }}
{{- if ne $field.Name "id" }}
	case "{{ lower $field.Name }}":
		{{ findByMethod $field $ }}
{{- end }}
{{- end }}
	default:
		return nil, fmt.Errorf("unsupported field: %s", field)
	}

	entities, err := query.All(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	return result, nil
}

// FindOneBy finds one {{ $.Name }} by field value
func (r *{{ $.Name }}RepositoryImpl) FindOneBy(ctx context.Context, field string, value any) (*{{ $.Name }}DomainModel, error) {
	results, err := r.FindBy(ctx, field, value)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("%w: {{ lower $.Name }} %s=%v", entdomain.ErrNotFound, field, value)
	}
	return results[0], nil
}

// WithTx executes a function within a transaction
func (r *{{ $.Name }}RepositoryImpl) WithTx(ctx context.Context, fn func(repo {{ $.Name }}Repository) error) error {
	tx, err := r.client.Tx(ctx)
	if err != nil {
		return err
	}

	txRepo := &{{ $.Name }}RepositoryImpl{client: tx.Client()}

	defer func() {
		if v := recover(); v != nil {
			tx.Rollback()
			panic(v)
		}
	}()

	if err := fn(txRepo); err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			return fmt.Errorf("tx err: %v, rollback err: %v", err, rerr)
		}
		return err
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("committing transaction: %v", err)
	}

	return nil
}

// entToDomain converts an ent entity to domain model
func (r *{{ $.Name }}RepositoryImpl) entToDomain(entity *{{ $.Name }}) *{{ $.Name }}DomainModel {
	if entity == nil {
		return nil
	}

	return &{{ $.Name }}DomainModel{
		{{ $.ID.StructField }}: entity.{{ $.ID.StructField }},
{{- range $field := $domainFields }}
{{- if ne $field.Name "id" }}
		{{ generateEntToDomainFieldAssignment $field }}
{{- end }}
{{- end }}
	}
}

{{- range $field := uniqueLookupFields $ }}

// FindBy{{ $field.StructField }} finds a {{ $.Name }} by {{ $field.Name }}
func (r *{{ $.Name }}RepositoryImpl) FindBy{{ $field.StructField }}(ctx context.Context, {{ lower $field.Name }} {{ $field.Type }}) (*{{ $.Name }}DomainModel, error) {
	return r.FindOneBy(ctx, "{{ lower $field.Name }}", {{ lower $field.Name }})
}
{{- end }}

{{- range $field := rangeLookupFields $ }}

// FindBy{{ $field.StructField }}Range finds {{ $.Name }}s by {{ $field.Name }} range
func (r *{{ $.Name }}RepositoryImpl) FindBy{{ $field.StructField }}Range(ctx context.Context, start, end time.Time) ([]*{{ $.Name }}DomainModel, error) {
	query := r.client.{{ $.Name }}.Query().
		Where({{ $.Package }}.{{ $field.StructField }}GTE(start)).
		Where({{ $.Package }}.{{ $field.StructField }}LT(end))

	entities, err := query.All(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*{{ $.Name }}DomainModel, len(entities))
	for i, entity := range entities {
		result[i] = r.entToDomain(entity)
	}

	return result, nil
}
{{- end }}

{{- end }}